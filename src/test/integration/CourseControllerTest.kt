import com.ktprj.KtApiApplication
import com.ktprj.dto.CourseDto
import com.ktprj.entities.Course
import com.ktprj.entities.Instructor
import com.ktprj.repository.CourseRepository
import com.ktprj.repository.InstructorRepository
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.web.reactive.server.WebTestClient

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = arrayOf(KtApiApplication::class))
@ActiveProfiles("test")
@AutoConfigureWebTestClient
class CourseControllerTest {

    @Autowired
    lateinit var webTestClient: WebTestClient

    @Autowired
    lateinit var courseRepository: CourseRepository

    @Autowired
    lateinit var instructorRepository: InstructorRepository

    @BeforeEach
    fun cleanDataBase() {
        courseRepository.deleteAll()
        instructorRepository.deleteAll()
    }

    @Test
    fun willGetNotFoundIfDeletingANoneExistingCourse() {
        val errorResponse =
            webTestClient.delete().uri("/courses/delete/{id}", 22323).exchange().expectStatus().isBadRequest.expectBody(
                String::class.java
            ).returnResult().responseBody

        Assertions.assertEquals("Course Not Found", errorResponse!!)
    }

    @Test
    fun willDeleteAnExistingCourse() {
        val instructor = instructorRepository.save(Instructor(null, "Joe"))
        val deletingCourse = courseRepository.save(Course(null, "x", "y", instructor))

        val deletedCourse = webTestClient.delete().uri("/courses/delete/{id}", deletingCourse.id).exchange()
            .expectStatus().isOk.expectBody(
                String::class.java
            ).returnResult().responseBody

        Assertions.assertEquals("DELETED ${deletingCourse.id}", deletedCourse)
    }

    @Test
    fun willUpdateExistingCourse() {
        val instructor = instructorRepository.save(Instructor(null, "Joe"))
        val updatingCourse = courseRepository.save(Course(null, "x", "y", instructor))

        val updatedCourse = webTestClient.put().uri("/courses/update/{id}", updatingCourse.id)
            .bodyValue(CourseDto(id = null, name = "a", category = "b", instructorId = instructor.id!!)).exchange()
            .expectStatus().isOk.expectBody(
                CourseDto::class.java
            ).returnResult().responseBody

        Assertions.assertTrue(updatedCourse?.id == updatingCourse.id)
        Assertions.assertTrue(updatedCourse?.name != updatingCourse.name)
        Assertions.assertTrue(updatedCourse?.category != updatingCourse.category)
    }

    @Test
    fun willGetNotFoundIfUpdatingANoneExistingCourse() {

        val errorResponse = webTestClient.put().uri("/courses/update/{id}", 22323)
            .bodyValue(CourseDto(id = null, name = "x", category = "y", instructorId = -1)).exchange()
            .expectStatus().isBadRequest.expectBody(String::class.java).returnResult().responseBody

        Assertions.assertEquals("Course Not Found", errorResponse!!)
    }

    @Test
    fun willFindAllCoursesButThereIsNotASingleOne() {
        val emptyListOfCourses = webTestClient.get().uri("/courses/all").exchange()
            .expectStatus().is2xxSuccessful.expectBody(List::class.java).returnResult().responseBody

        Assertions.assertTrue(emptyListOfCourses!!.isEmpty())
    }

    @Test
    fun canNotProvideAnIdForANewCourse() {
        val reqCourseBody: CourseDto = CourseDto(1, "x", "y", instructorId = -1)

        val exceptionResponse = webTestClient.post().uri("/courses/create").bodyValue(reqCourseBody).exchange()
            .expectStatus().isBadRequest.expectBody(String::class.java).returnResult().responseBody

        Assertions.assertEquals("Id is autogenerated, it is not a required field", exceptionResponse!!)

    }

    @Test
    fun shouldCreateANewCourse() {
        val instructor = instructorRepository.save(Instructor(null, "Joe"))
        val reqCourseBody: CourseDto = CourseDto(null, "x", "y", instructorId = instructor.id!!)

        val createdCourse = webTestClient.post().uri("/courses/create").bodyValue(reqCourseBody).exchange()
            .expectStatus().is2xxSuccessful.expectBody(CourseDto::class.java).returnResult().responseBody

        Assertions.assertNotEquals(reqCourseBody, createdCourse)
        Assertions.assertTrue(createdCourse?.id != null)
    }

    @Test
    fun shouldPostAnewCourseWillFailWithInvalidValues() {

        val reqCourseBody: CourseDto = CourseDto(null, "", "", -1)

        val allErrors = webTestClient.post().uri("/courses/create").bodyValue(reqCourseBody).exchange()
            .expectStatus().isBadRequest.expectBody(List::class.java).returnResult().responseBody


        Assertions.assertFalse(allErrors!!.isEmpty())
    }

}